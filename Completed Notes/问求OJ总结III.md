# 问求OJ技巧总结

Author: Daniel Liu
Contact me: 191240030@smail.nju.edu.cn
Course: Problem Solving. NJU

[TOC]

### 3-1 Practice Mode

#### A. DPS

模拟题。这种题目算法层面上难度不大，但是要求写代码很细致，否则调试会很耗时间

代码：在数据类型上出现了不少问题。由于int除法总是会在运算过程中就向下取整，我们为了将结果向上取整应该使用double类型。

#### B. 网抑云

算法：本题有集和求交和滑动窗口两种解法。

集合求交需要用list实现集合，这样增删元素比较方便(题解中list存储区间端点，由于数据最多10^5^，我用list存储集和元素，这样每次遍历删除后元素的数量会变少)。使用list之后可以卡在时间范围内，其他方法总是TLE

滑动窗口是我一开始的本能反应，但是一开始认为每次滑动都需要遍历窗口内的元素判断是否符合要求遍放弃了。实际上我们只需要一个变量sum保存当前窗口内元素种类个数，判断是否与元素个数相等就知道有没有重复的。

#### C. 时钟

本题是模拟题，关键在于找到匹配时钟的方法。由于时钟精确到分钟，一天内有1440分钟，遍历全部情况即可。

#### D. 减肥计划

算法：需要计算一段连续时间内体重的变化，首先想到**前缀和**(一段连续区间的和常用此方法)。随后对前缀和排序，进行尺取法。过程中注意排序后的前缀和如何找到对应的天数下标。

### 3-2 动态规划 Dynamic Programming



#### A. 问求晚宴

算法：简单的动态规划题，用记忆化搜索和递推都没有什么障碍。求和的过程可以通过**前缀和**降到O(1)

代码：写这道题的时候出现了两个低级的代码错误：

* 数组越界：一开始范围设置成了50，当k=50时会发生越界，但是结果是WA而非RTE
* 变量名误用：在循环判断/条件判断的地方把两个变量名搞混了，下次要注意尽量用区别度大的变量名，容易辨识的最好

#### B. de_nuke

问[a, b]中有多少个数满足各位之和与各位平方和为素数

算法：这是一条典型的**数位DP**。我们可以将问题转化为求解[1, a-1], [a, b]两个范围，将结果在求差即可(数据范围很大，但是十进制位数是有限的，我们依然可以先把一定范围内的全部素数求出来)

针对任意一个数x，可用记忆化搜索找到[1,x]范围内解的个数：我们逐位访问，同时用flag表示前几位数字都取了x相应位的最大值。如果flag=1，显然为了不超过x，当前位也不能超过x相应位，反之当前位可取0-9。我们只需要记忆flag=0的情况下，pos, sum1, sum2三个数的运算结果就可通过本题。

代码：本题遇到了一个比较隐蔽的数据溢出错误：由于x最高可取到$10^{18}$，而int仅能保存最多10位数字，因而结果肯定会出现溢出。

#### C. 优惠券IV

算法：本质上是**区间DP**(状态转移的参数为区间端点)。本题我们可以用记忆化搜索solve(x1, y1, x2, y2)快速解决。若当前区间内只存在一个全家桶，我们无需裁剪；如果没有优惠券，发生错误，返回INF；若不止一张，我们遍历每一种切分方法(横切竖切都要考虑)。要注意的是本题用了前缀和的变种，针对每一个坐标(x, y)，我们记录(0, 0)到(x, y)范围内的全家桶数量，这样求(x1, y1)到(x2, y2)范围内的全家桶数量可以通过减去重合区间在O(1)内算出来。

#### D. 麻将II*

算法：本题的状态转移方程甚是巧妙。我们首先可以证明任何一种牌，aaa的数量只受到xxa, xax, axx数量的影响，通过增加状态的方式我们可以通过记忆化搜索解决本题(细节之处现在一时难以回想起来，总之难度挺大的)。

代码：本体出现了正负号写反等代码疏忽的问题。当赋值语句的内容很长时，特别容易出现漏项、添项、正负号的问题，一定要小心。除此之外，我还出现了审题的问题，麻将的编号从0开始，这违反常识，但是我们审题应该一切以题面为准

### 3-3 贪心算法 Greedy Algorithm

#### A. 足球巨星

算法：本题我前两次提交用了自己想的贪心算法，结果这种贪心性质是错误的。题目中将计拔学生的坐标转化为区间，然后将区间按照右范围升序(左范围降序)的方法排序，再进行贪心选择就可以了。本题比较有启发性的是将点**转化**为区间求解

代码：注意priority_queue包含在头文件\<queue\>中，格式为priority_queue<int, vector<int\>, less<>>  这里less表示大顶堆，小顶堆用greater<>。使用priority_queue存储结构体时，结构体要操作符重载(实现一个普通函数即可)

#### B. 定向队的比赛

算法：本题目的贪心选择比较容易想到：将每位选手每段距离的时间排序一下，选择最小的那个，但这样的复杂度是O(mnlog(mn))，会TLE。解决方法是利用每个人越跑越慢的性质，每次在每个人接下来会跑的距离段里挑出最小的，利用**比较**的话复杂度将会是O(mn)，将每个人下一段距离耗时存储在**优先队列**耗时O(nlogm)

#### C. 找零*

这题的贪心选择比较巧妙，证明起来也比较麻烦，目前我还不是特别明白

#### D. 分花雪月

算法：本题本质上就是要找最多有几个长度为k的序列，满足序列中后一个元素是前一个的两倍。像上学期的分花雪月那样，我们很难直接找出最多组成多少束花，于是用**二分查找**判断能否组成x束。问题落到了如何设计二分查找的check()上：

要解决的第一个问题是能否用贪心算法来判断是否可以组成x束，一个办法是利用目标值x。我们可以证明的一个性质是：若可以组成x束，则每束的第m种一定出现在所有花束第m+1种之前，通过替换法很容易证明a~1~a~2~...a~x~, b~1~b~2~...b~x~等一定按照顺序出现在序列中。这样我们第一次贪心地选择最短的x种花束，然后针对每一束第一种贪心地选择第二种、第三种...第二个问题是check的时间复杂度。二分查找的复杂度是O(logn)，从数据范围可以看出check复杂度最好是线性的，否则容易超时。因而我们采用双指针的方法，用一个数组记录前一轮为x束花选取的花的种类，后一个指针cur挨个遍历后面的种类，当本轮x束花全部找到匹配的花时，开始新的一轮，最后检查轮束是否可以到达k。这样一来，总的复杂度是O(nlogn)。

说到这里，我们也很容易意识到为什么直接用贪心算法解不出来，而判断能否组成x束时可以用贪心了：我们的贪心算法需要同时对x束花做贪心。因而给了贪心算法一个依赖条件后，就容易多了。

### 随堂测验 9.27（动态规划与贪心算法）

#### A. 勇者塞尔达与工匠

很简单的贪心算法，排序几次即可。

#### B. 勇士塞尔达与恶龙

算法：std的一维动态规划我没明白是什么意思。50%的数据可用二维解决，考试的时候状态转移方程推错了，晚上重做的时候用记忆化搜索解决了。

#### C. 勇士塞尔达与宝藏

树结构(可能有多个子结点)遍历，每个结点有一个value，不可取相连的结点

算法：记忆化搜索即可。用vector数组存放边（不需要构造出树来，稍加思索便知道只需要利用这些边），在递归中分两种情况，一种是取当前结点，然后以子结点的子结点为根进行递归，一种是不取当前结点，以子结点为根进行递归，取两者中更大的作为答案。由于每个结点作为根得到的最优解的值都是唯一的，我们可以用记忆化搜索。

C题比B题简单不少，考试的时候一条题目没有明确思路就先跳过

### 3-4 树 Tree

#### B. 塞尔达想要所有的宝藏

题意：二叉树结构中一个结点上设置guard可以保护该结点和相邻结点，问设置多少个guard可以覆盖整棵树

这题先用**先序遍历和中序遍历**重建树。如果用动态规划，记住这题状态比较多，要添加相应的状态维度。更快的方法是采用**贪心算法**：对于每个叶子结点而言，对它设置guard肯定不如对父结点设置guard。如果对父结点设置guard。利用这一方法我们从每个根结点依次上溯。本题的贪心需要通过**dfs**来实现，每次调用返回pair<bool, bool>表示是否有guard以及是否被保护。每个结点根据子结点的返回情况分类设置返回值，并按需修改全局变量ans。

做题过程中遇到两个坑：

1. memset多次用于很大的数组时，会TLE。本题memset了最多$3000\times 2.1\times 10^6$个结构体，而算法中完全可以不将它们清零。
2. 本题中的dfs会遇到这种情况：当前结点的两个子结点都被保护但没有guard，我们对于非根结点进行贪心选择，返回(false, false)，即强制要求它的父结点设置guard。这本质上在当前结点和父结点之间建立了联系。然而，由于根结点没有父结点，这种联系是不成立的，我们需要单独考虑根结点的两个子结点遇到那种情况时的策略。由于忽视了这个因素，我的很多输出比标答少1.

#### C. 寻找DIO

题意：给定一棵带权树，求$AB+AC+BC$的最大值

算法总体思路比较清晰：先**找到一条直径**，再**遍历**每个点，到两个端点距离和最大的点，可以用**dfs**。

求解带权树的**直径**：先任选一个结点dfs，找到距离最远的点A(必为直径一个端点)，然后从A开始dfs找到距离最远的点B，AB之间的path即为直径。随后我们通过从A和从B的dfs标记出每个结点到AB两点的距离和，选出最大的点C，则$AB+AC+BC$最大值就可以算出来了。

#### D. 白色相簿

题意：从树上一个结点开始遍历整棵树并返回根结点，每个时刻可以选择移动到相邻点或返回之前某一时刻(位置不变)，每个时刻有状态对(pos, time)。要求状态序列中$time_{max}$最小，同时不存在$p_1 = p_2\land t_1 = t_2$.输出状态序列。

本题需要先想到最小的$time_{max}$就是$degree_{max}$（题解中指出可以“隐隐约约”感觉到这一点，或许有时候做算法题需要这种感觉，先做出一个猜想，再给出自己的依据），因为每遍历完一棵子树返回时时刻都必须不同，最多有$degree_{max}$棵子树。从某一个结点遍历子树时，我们不妨要求每次子树的返回时刻都是上一次在该结点的后一个时刻(可以在dfs中添加back_time要求做到这一点)，当遇到current_time将要超过最大值时，我们根据back_time和剩余子树个数计算出返回的时刻(这里一开始没明白，卡了一会儿)，再遍历剩余子树。最后调整current_time，满足返回时刻为back_time。状态序列存放在栈中。

一开始代码中有一个低级错误：遍历子树的循环中调整current_time时，需要用到剩余子树个数，但是计算时我用了connect[x].size()而非connect[pos].size()，变量用混了。

#### E. 爱疯工厂

题意：给定一棵树和结点编号，将树还原为一个链表(每个结点编号不变，但在链表中的位置不定，根结点为1，且为链表头)，要求链表在只允许$p[x]=p[p[x]]$(将父结点设置为父结点的父结点)操作时，用最小的操作数可以得到原来的树。

算法思路比较清晰。显然深度越深的子树越应该放在链表后面，从而整棵子树上移距离更小。我们首先用**dfs**计算出每个结点的深度，把深度浅的子树放在前面，并为每个结点赋予在链表中的位置，根据位置还原链表。得到链表后**从左往右**顺序访问，若结点的父结点不是树上的父结点，就不断将父结点调整为前一个结点（必须从左往右，一开始我担心从左往右是错误的，实际上由于根结点在同一深度且父结点相同的结点都可以通过操作连接到父结点，从左往右可以一次性将更多结点放到距离目标位置更近的地方。当时我选择了从右往左，想得不透彻）。

本次OJ的题目都有一些贪心的思想在里面，其贪心选择有一定的技巧性，且其正确性如果不能立刻反应过来，做题比较容易没把握。DP和贪心是图论算法中很重要的思想，相关题目还需要多学多练。

### 3-5 并查集 Disjoint Set Union

#### A. 赛尔耗

使用压缩路径和按秩合并即可，一条简单的并查集

#### B. 爱好核平的水龙

使用LCA(最近公共祖先)和树上差分算法。

**求解LCA**需要回溯遍历整棵树，当一对结点中两个都被访问到时，我们就可以使先被访问到的那个结点向根结点靠近，遇到的第一个没有回溯完成的结点就是LCA。这个过程可以**用并查集的压缩路径来加速**。

**树上差分**的结果可以用来还原整棵树。使用差分的方法我们就不需要每次都调整数据结构中大量结点的值，本题中最多调整4个即可，最后用dfs还原树。

#### C. yls wants you!

这条题目代码量贼大，不过思路挺有借鉴意义。

首先是为了满足**撤销操作**的需求，我们定义了一个结构体**栈**来**存放每次执行对数据结构的改变**。

其次，为了快速算出集合内任意两个元素间的异或结果（我们仅知道两个元素的异或结果，而不知道任意一个具体元素的值，维护这种关系R是难点之一），我们在每个结点里添加了xor_with_f，在**维护并查集的时候顺带修改这个值**，保证存放的是与当前结点的父结点的异或值（find_set, union里都会修改这个值，注意在栈中记录相关调整）。这样，当我们需要运算同一个集合内两个元素a, b时，由于调用了会压缩路径的find_set，它们的xor_with_f都是与集和代表元素r的异或值，这两个值异或即可得到$(a\oplus r)\oplus(b\oplus r) = a\oplus b$

#### D. 原始人

代码量很大。过程中需要维护一个数据结构保存那些铁定不在同一集和里的元素。我在每个结点里存放了一个指向set的指针，只有representitive的指针会真正指向一块内存区域。这样就不会MLE了。

### 3-6 生成树 Spanning Tree

#### A. 歌曲评分

本题主要难度在于结合异或运算的性质进行图建模。我们可以将第一首歌一直异或到第k首的结果记作$S_k$，那么条件中给出的$B_{ij}$可以看作求出$S_{i-1}$和$S_j$(不妨设$i<j$)异或值的代价。这样我们只要能够求出$S_0$到$S_n$彼此间所有的异或值，就一定能得到每一首歌的评分。这样一来，如果将$B_{ij}$视作边的权，就可以通过寻找最小生成树来找到答案。本题边相对点比较少，用Kruskal快一点。

#### B. 内卷赢家

简单的MST题，用Prim和Kruskal都可以。

#### C. 空中公路

这是我出的题，用到了次小生成树的思想。找到MST后枚举每一条边，如果在树内直接删掉计算，如果不在则删除$e+T$环内权值最大的边。在求MST的过程中我们需要维护path数组来保存MST的路径uv上权值最大的边。

#### E. 内卷网络

**矩阵树定理**，难点在于求解行列式。直接用定义会TLE，可以用高斯消元法，但是会非常繁琐。可以找到通项公式（找规律有一定概率找到，行列式化简不知道可不可以做出来）。最后数据会相当大，需要用到大数计算。用Python可以略过大数计算的问题。

### 3-7 搜索 Searching

#### A. 下副本前的布阵

可以转化为图模型来解决，DFS比BFS方便一些，主要技巧是**康托展开**，对于全排列相关的状态压缩来说，康托展开非常高效。

本题前几次提交WA，因为对题解中康托展开没有理解透彻，编程实现的时候就写错了。读题解一定要认真，公式每一项的含义必须明白无误。

#### **B. ** 不讲武德的mls

直接用DFS很方便，要注意的是需要保存每一个节点的DFS结果，利用无后效性控制时间。

实现的时候犯了一个低级错误，矩阵长宽为n, m，结果循环条件判断里i, j都用n来判断了。

#### C. 两开花（两开花）

BFS实现，题目有些模拟的意味，对于不同的房间的功能需要有一个好的抽象实现。图论算法题中很多时候需要将状态作为vertex，本题中H类房间增加hair相当于给状态添加了一个维度。

前几次提交都TLE，题中明确说了存储的毫毛不超过3根，但是做题的时候按照无限根的情况来考虑了，实现的方法没有问题，但是由于无限根带来的巨大状态数使得通过数组实现vis不被允许，用更慢的方法来实现此功能导致TLE。这属于一个严重的审题失误。

#### D. 糖豆人的最新关卡

题目中的思维反转很有意思，使得复杂度大大降低，每个回合只需要一次BFS就可以求出所有玩家的体力损失。此外，与路径相关的问题通常都使用BFS而非DFS，BFS得到的路径通常比DFS更优。

这题卡了很久很久，一定要注意一点：BFS中存储的元素**未必按照发现的顺序就是对的**，有时候用queue就行，有时候需要priority_queue。本题寻找最小的dis，而safe区域内dis都是0，显然按照简单粗暴的发现顺序不行，故需要将已发现且未作为cur的元素按照dis排序，每次选最小的来发现新元素，从而确保新元素的dis最小。

### 3-8 单源最短路径 Single-source Shortest Paths

#### A. 通讯网络

本题在有向图中寻找从源K到每个节点再返回的最大值。通过两次Dijkstra可以解决，第一次用题中给的边算，第二次将每条边反过来算，这样可以保证不用多源最短路径算法。

#### B. 科学翘课

题目要求找到从一个节点A到另一个节点B所有最短路径上的节点，求出在不经过它们的情况下从C到D的最短路径长度。

我们可以首先通过一次Dijkstra得到dist数组，然后通过一次DFS标记出从A到B所有最短路径上的节点，做到这一点需要利用最短路径的性质$\delta(s,v)=\delta(s,u)+w(u,v)$.标记这些点之后，我们通过一次Dijkstra算出C到D的最短路径，注意不能经过标记出的点。

本题WA了很多次，原因是审题不清：题目中说无向图，但是我按照有向图来做了。

#### C. 景点修复

这题出成了多源最短路径，利用Floyd算法，需要对Floyd的循环含义有比较深刻的理解。

本题一开始图中某些节点不可以经过，这些不可以经过的节点会在随后的某个时刻t可以经过。我们得到一个按照时间顺序的询问序列，回复那个时刻是否有从x到y的path。

要做到这一点，我们只需要最Floyd最外层的循环按照t的顺序完成。每次进入循环时检查是否有新的询问可在当前的时间区间内回复。

#### D. 布袋跳

本题可以加深对图论建模的理解。我们利用图模型建模时，通常V表示状态的集合。本题题面上的各个节点、边无法通过图模型建模，最终通过(current, previous)作为V实现图模型，在Dijkstra算法中，vis, distance等数组需要增加一个维度以适应状态数的增加，RELAX操作也变成了$dist(i_1, i_2) = min(dist(i_1, i_2), dist(i_2, i_3) + path\_length(i_2, i_1)\times(w(i_2) + w(i_3)))$

总之，扩充状态维度增加了图的建模能力，但是这对抽象思维的要求也更高。图论为我们提供了很多有力的算法工具，很多时候问题的难点落在了如何去建立合适的模型，将这些算法应用上去。

### 3-9 多源最短路径 All-Pairs Shortest Paths

#### A. 武林大会

多源最短路径加上组合计数内容

用Floyd求出两点间最短距离，并在算法过程中调整二维数组cnt，记录两点间最短路径的条数。总体较为简单。

#### B. 巫妖王之怒

多源最短路径+动态规划

通过调整版的Floyd算法进行预处理，求出从一点到另一点所需的最低等级。

随后进行动态规划，将k个可以启动仪式的地点是否启动过编码为k位二进制数s。c\[s\]\[p\]记录在状态编码，从s=1到$2^k-1$递推。

做题过程中有一处ksr[j]写成了j，导致多次WA 20%

#### C. 不办实事的贪官

单源最短路径，判断添加任一条路径(u,v)是否改变从s到t的最短路径长度。用多源最短路径会TLE。

两次dijkstra求出从s和t的最短路径，$dis_{su}+dis_{uv}+dis_{vt}$和$dis_{sv}+dis_{vu}+dis_{ut}$若都大于等于$dis_{st}$，则可以添加uv。

这题要注意需要返回int的函数未设置return x在clion上不会error，但在判题机会RE

#### D. 单身狗的烦恼

单源最短路径题。

每个节点也有一个cost，如果将其作为旅游目的地则加上这个cost。对于每一点需要求出到一个地方（可以是它自身）旅游来回的路费加上当地开销的最小值。

这题可以添加一个虚构节点与n个节点间都有一条单向边，边的weight设置为cost，图的其他每一条边的weight设置为原来的两倍（来回总代价）。这样从虚构节点进行一次dijkstra，到每个节点的最短路径即最小代价。

### 3-10 连通度 Connectivity

#### A. 道路建设

本题在**无向图**中找到所有边连通分量并找出出度为1的分量，计算可得到答案。用**Tarjan**算法。

多组数据输入的时候注意edges.clear()

#### B. 长路将近

本题等价于在有向图中添加多少边可以成为强连通图。

通过**Tarjan**算法可将输入图转化为弱连通图森林（强连通分量可以视作一个vertex），求出每个森林入度为0和出度为0的节点数m和n，答案即为$max(\sum m,\sum n)$.题目中我也用了**并查集**来表示在同一个若连通图中的强连通节点。

#### C. 炸桥

使用**Tarjan**算法找到**无向图中的桥**。(u, v)是桥的条件是$dfn[u]<low[v]$。

注意题目中对重边情况的处理，我通过map<int, int>来记录edges，如果遇到重边则将w设置为INF，这样ans是INF就输出-1

#### D. 最靓的仔

对**有向图**使用**Tarjan**算法，找到出度为0的强连通分量，如果只有一个这样的分量，输出其中节点数，否则输出0.

Tarjan算法和许多其他DFS算法有一个**易错点**：如果输入的图不是连通的，我们需要在循环中调用DFS，否则只会遍历森林中的某一棵树.



### 3-11 旅行问题 Traversity

### 3-12 匹配和覆盖 Matching and Factorization

#### A. 金箍棒 II

本题求$m\times n$的矩阵中，覆盖所有\*所需的金箍棒的最小值。建模过程很巧妙，将每行/列连续的点作为行/列点，从而形成了两个集合，\*表示这个位置的行点和列点间有一条边。我们找到这个二部图的最小点覆盖即可，由Konig定理可知，二部图的最小点覆盖数即为它的最大匹配数。用匈牙利算法即可。

本题TLE了很久，最后才发现，匈牙利算法内每次对used清零只有用memset能AC。事实上，**memset会比手动循环效率高很多**。

#### B. 打游戏不讲武德

本题较为简单，通过计算距离在我方船只和敌方船只间可以建立边的关系，如果存在孤立点则输出bu jiang wu de，如果不存在则可以求解。我们需要求解出最小边覆盖，通过$\alpha'(G)+\beta'(G)=n$可知，用匈牙利算法求出最大匹配然后用总定点数减去最大匹配即可得到最小边覆盖。

#### C. 猫狗双全

本题通过两次循环为奇数格子和偶数格子编号，然后再循环一次建林相邻关系，求出最大匹配即可，本题也用匈牙利算法。

#### D. 奶茶

本题用到了一定的组合数学知识，由霍尔定理可以推出二分图的最大匹配数为：
$$
|A|-max_{S\subseteq A}\{|S|-|N(S)|\}
$$
根据这个式子就可以算出结果了。

### 3-13 网络流-I Network Flow

#### A. 热心市民杰哥

本题非常直观的最大流模板题，用Dinic算法+邻接矩阵即可解决

#### B. 上学

本题为17级期末考试原题，大意是用从A到B再到S，途中没有重合的节点。

建模方法：首先，每个节点不能重复，因而可以通过添加一个节点与该节点相连且capacity为1的方法转化。接着将B视作汇点，在添加一个源点以capacity为1分别与A, S相连，求最大流。最后用Dinic算法，若结果为2，则存在这样的走法，反之不存在。

本题出现了严重的审题错误，将题目中无重点看成了无重边。

#### C. 机房的诱惑

最大流算法选择模型，这种题目可用最大流-最小割定理。A机房和B机房作为源节点和汇节点，每个人与A, B相连边的容量表示代价。此外，如果两个人不在同一个机房会导致额外的代价，我们通过capacity为代价的边将其相连。我们要求总代价最小，可以求最小割集，被割开的边表示它的代价被选择了。显然最后每个人要么去机房A，要么去机房B，而有关系的两人如果不在同一个机房，他们之间的代价要被考虑，也就是说那条边会被割开。由此可知，求出图上一个最小割就是答案。那么通过最大流-最小割定理，我们通过Dinic求最大流即可。

#### D. 球迷福利

建模方法：超级源点指向所有球衣，所有球裤指向超级汇点，由于每个球迷只能选择一套球衣球裤，将球迷建模为相连边容量为1的节点。这样再将球迷与他们喜欢的球衣球裤相连，求最大流算法即可得到最多满足的球迷数。

本题TLE了几次。由于数据量较大，本题只能通过vector实现Dinic。此外，由于本题球迷、球衣、球裤分别都不超过10000，而边的关系M1, M2数量也不超过20000，可知很多节点实际上可以不考虑（例如一件球衣或球裤没人喜欢，或者一个球迷只列出了喜欢的球衣、球裤甚至都没列出）。通过一个valid数组记录这些节点是否有促成最大流的可能，可以为dfs和bfs省去很大计算量，从而控制在规定时间内通过。

### 3-14 网络流-II Network Flow

#### A. 问求大酒店

简单的模板题

#### B. 社刊售卖

本题重点在于建模。用一个数组保存每个人最后去过的班级编号(如果还没去过任何班级，编号就是他自身)。然后依次遍历班级(班级访问有次序)，对去该班级的所有人，如果这个人去过之前某个班，则从他去过的最后一个班连接一条INF边指向当前班级，反之增加源点到该班级的容量。根据该班级售出的最大量设置与汇点的边容量。

提交TLE和WA了几次。TLE是因为模型不够优化(不是主要原因，后来发现Dinic模板中DFS没用vis导致很慢)。WA是因为修改代码的过程中忽视了各个节点编号的含义。这种题目一定要注意将具体事物抽象成节点时编号的偏移量，修改代码时这部分尤其要注意。

#### C. 迪迦的求助

思路很清晰：首先用Dijkstra和dfs找出城市1到城市n的所有最短路径，然后根据题意在最短路径上跑Dinic

WA了几次，题目表意有些含糊。题中未说城市间有几条路径，我直接按照没有重边做了，实际上应该取所有长度的最小值。遇到这种情况可以直接理解为有重边做，更加保险些。

#### D. 机房的诱惑（加强版）

二选一模型的升级版。想出了两个正确的模型(其中一个会重复计算额外开销，结果需要减去这些开销)，还有一个简化的模型正确性有问题，这三个模型和yls，zls讨论过了，可以看聊天记录中的截图。

通过本题找到了之前Dinic模板的漏洞：dfs没添加vis导致很慢。第二种正确模型可以800+ms通过，第一种则TLE。添加vis后第二种80+ms，第一种50+ms.

### 3-15-矩阵计算-Matrix

#### A. 方程

高斯消元法。注意数组存放矩阵时实现上的易错点。

#### B. 击剑

动态规划思想+矩阵计算+概率论

可以根据两个人的位置构建$N^2$个状态，状态间的转移可以得到一个方程组，通过高斯消元法求解即可。

过程中WA了一次，原因是浮点数除以0得到了NaN（没有考虑到孤立点）

#### D. 蚂蚁

求出递推式$f(n) = 2f(n-1) + 3f(n-2)$，可以得到
$$
\begin{bmatrix}
f(n)\\
f(n-1)
\end{bmatrix}
=\begin{bmatrix}
a & b\\
1 & 0\\
\end{bmatrix}
\begin{bmatrix}
f(n-1)\\
f(n-2)
\end{bmatrix}=
\begin{bmatrix}
a & b\\
1 & 0\\
\end{bmatrix}^{n-1}
\begin{bmatrix}
f(1)\\
f(0)\end{bmatrix}
$$
求出矩阵特征值特征向量后得到一个含有$\frac{3^n}{4}$的式子，由于n很大，我们要用快速幂并取模。取模过程中发现除以四不好解决，于是在快速幂过程中将模值设为$4\times MOD$,这样就能对结果除以四再对MOD取模答案正确了。

#### E. 序列

将问题转化为图，可以相邻的两个数字邻接矩阵中边设为1。对无向图的邻接矩阵M而言，$M^k$中的任意$m_{ij}$即表示从i出发到j经过k条边的走法数量，本题利用这个性质求解。k的数值很大，将快速幂的思想应用与矩阵的幂运算即可，过程中要注意矩阵运算通过数组实现的细节。