# 问题求解OJ技巧总结 IV

Author: Daniel Liu
Contact Me: 19120030@smail.nju.edu.cn
Course: Problem Solving. NJU

## 4-1 动态规划

### A Project

A题是实现Project中Graph类和Edge类的成员函数。体验了在Windows上使用Git、Powershell脚本，用Clion管理一个完整的项目。

在编程技巧上，实现这些成员函数时需要谨慎考虑类中数据的实现方式，最好在编写之前想清楚成员函数对类型数据成员会有哪些修改。本题中一些函数会修改图的结构(增删节点、边)，我一开始的设计模式无法高效进行节点的删除，因而大费周章把所有函数重新实现了一遍。现在的方法是用std::vector\<std::pair\<int, std::vector\<int\>*\>\>来保存节点及其相邻点，相邻点用动态存储进行管理。

另外，STL使用时出现了很多低级错误。需要不断练习才能使C++水平日益精进，不能忘了CS的基本功。

### B 了不起的修仙模拟器

通过动态规划实现，不过我一开始想到的动态规划太复杂了：
$$
c(n,p)=\min(\min_{1\leq i < n}(c(i,p)+\frac{\sum_{j=i}^{n-1}n_j}{p}),\min_{1\leq i < p}(c(n,i)+\frac{\sum_{j=i}^{p-1}p_j}{n}))
$$
实际上，我们每次递推只需要把$i$加上1，也即只考虑：
$$
c(n,p)=\min(c(n-1,p)+\frac{n_{n-1}}{p},c(n,p-1)+\frac{p_{p-1}}{n})
$$
观察第一个式子可以发现有很多重复计算。

### C 招聘黑工

做本题的过程非常曲折，前前后后尝试了很多种方法，结果最终成功的还是一开始想到但没想明白的：简单的递推。

先罗列几个错误的思路：1. **差分约束：**题目可以找到很多个不等式关系，且都可以转化为差分约束的形式$x_i-x_j\leq b$。通过添加超源点并运行最短路算法，可以找到差分系统的一个可行解，然而这个解并不一定满足最大-最小值是最小的。2. **最短路：**想了很多图论算法，似乎都不能应用上去，收差分约束的启发尝试了用最短路建模，但是整个图几乎是一条线，且很多地方不连通。另外，源点到各个节点的最短路的条件可能不同，因而不能组合出一个全局解。3. **动态规划：**本题无法找到最优子结构，两个子问题的解不一定能组合出全局最优解。

**递推：**递推其实非常简单，用hmin, hmax记录总的最小和最大，$x,y$记录当前人物可能的最小最大等级。当时觉得这种方法有点**贪心**的思想(实际上不是，这个问题连最优子结构都没有)，不停想找其中漏洞。当时找到的反例实际上是不会发生的：由于记录的都是区间，我觉得这个hmin和hmax都是理论最值，实际上可能不会取到。事实上，递推过程中每次更新hmin或hmax，最值都会与x, y都相等，也就是说必然会取到。因为这个问题没想清楚，当时就把没有把握的递推思路给抛弃了。

**二分法：**本题求最大-最小的最小值，实际上就是(最大差值的最小值)，可以想到用二分法解决。对于每个值$x$，可以用递推判断是否可行。判断一个$x$可不可行要比直接找到一个准确答案容易得多。

本题告诉我一个道理：实事求是。确实有很多现实问题可以通过经典算法建模并解决，但是递推等基本的算法思想有着更为广泛的应用场景。经典算法、经典模型都是前人智慧的结晶，但是其应用范围和使用方法相对固定。不能带着套用经典算法模板的思维面对问题，那些朴素的算法思想往往也蕴含着伟大的真理。

***

## 4-2 置换群

### A Project

本周优化了数据结构的实现，用map<int, vector\<int\>\>来存放边，用map<pair<int, int>, int>来存放权重，这样效率会高很多，代码也简洁得多。其中一些C++机制还不是很熟练，以后有机会最好选修高级程设。

### B Product of Permutations

本题需要将一大串cycle化为一个等价的相互dijoint的cycle乘积。思路比较清晰：

1. 首先从字符串输入中读取数字。输入每行是"(1 2 4)(2 3 5 7)(1 10 9)"这种形式，我创建了一个isstringstream对象scin，然后连续用getline(scin, buf, ')')将string拆分成多个"(1 2 4"形式的字符串，删除string第一个元素，然后再用这个string创建isstringstream对象sscin，用sscin >> tmp读取数字并存放在数组中。
2. 将所有数字映射到1...n中，将映射值存放在rec数组中，用pos_rec记录每个映射值当前位置下标。然后按照cycle的顺序将rec中的数字轮换，更新pos_rec。这一步逻辑控制比较困难，很多细节容易忽略，如果代码简洁一些会让人更有看下去的欲望。
3. 得到rec后，即可用C题的方法将轮换后的顺序转化为不相交的轮换形式：从小到大遍历rec，遇到rec[i]$\neq$i 时开始寻找一个轮换，并更新rec。

### C Split of Permutations

B题第三步的方法，难度不大。

***

## 4-3 群论 + 数论

### A Project

本周在前两周的基础上设计两个类，实现无向图和无向有权图，目前我对虚函数和动态绑定的认知比较模糊(最好选修高级程设)，侯捷C++的知识点忘了很多。

实现上要注意**自环**，无向图的自环会给节点带来2个度数。

### B Order of Permutation

现根据输入的排列转化为几个轮换的乘积，每个轮换的阶数就是其长度，对每个轮换的阶数取最小公倍数即为输入排列的阶数。

### C 抽象代数的结构判定

没什么难度，通过Cayley Table检查是代数结构、半群、幺半群还是群。

### D 绝地求生

数论题。可以发现问题等价于求解$1\leq x,y\leq \frac{n}{2}$范围内，满足$\gcd(x,y)$的$(x,y)$对的个数。最后得到的式子是$\varphi(1)+2(\sum_{i=2}^{\lfloor\frac{n}{2}\rfloor} \varphi(i))+2$，求出欧拉函数即可。快速求欧拉函数有现成算法，已更新到模板。

***

## 4-4 数论

### A Project

本周加入了泛型编程的思想，使得权重可以为不同类型

### B 离散对数

本题求解离散对数$a^x\equiv b\mod q$（输出最小正整数$x$），用到BSGS算法。实现过程没有什么难度，注意用map来保存计算出的$B$以防TLE。

### C 质数判定

用miller-rabin算法判断一个大数是否是素数。在$2^{32}$的范围内，用费马素性判断即可，但是$2^{64}$内上述方法出错率很高，用miller-rabin的素性判断正确率会高很多，选取提交中的那组$a$则可以完全确保$2^{64}$内的正确性。

***

## 4-5 数论

### A 丝血之狼

本质上是要计算$\binom{n}{m}\mod p$，这三个数都可以达到$10^{18}$。本题用到了因数分解、卢卡斯定理、组合数计算、乘法逆元、快速幂、快速乘、中国剩余定理，非常综合。

思路如下：首先将$p$分解(保证不多于5个不同质数，且都不太大)为$\prod q_i$。然后对每个$q_i$用卢卡斯定理将大组合数模运算分解成很多个小组合数的乘积，计算小组合数时用$\binom{n}{m} = \frac{n\cdots (n-m+1)}{1\cdots m}\mod q$，除法用乘法逆元替代，乘法逆元的计算方法是利用费马定理$a^{p-1}\equiv1(\mod p)$计算$a^{p-2}$，计算用快速幂。由于快速幂常数很大，这里的对$1\cdots m$分别求逆元很慢，可以求出它们的乘积，然后用一次快速幂求出逆元。得到$\binom{n}{m}\mod q_i$后，用中国剩余定理计算出$\binom{n}{m}\mod p$.

### B 化学方程式

字符串处理题，我用的Python，算法不难，主要是考验程序设计功力。

### C 瞬移之狼

本题用状态dp可以求出，但是我没想出来怎么做。

我用的方法是：对所有数字两两求gcd，计算出得到这个gcd的最小代价，这样就得到了一组新的数字及其代价。递归重复上述步骤直到只剩下一个gcd，其cost即为最小代价。

***

## 4-6 密码学与编码学

### A Project

本次通过C++静态成员函数实现BFS和DFS，掌握了functional和optional的使用方法。

### B Base64

编码转化，用Python很简单，但是我没有妥善处理输入的问题，导致不停RE。整个题目只需要两行：

```python
import base64, sys
print(base64.b64encode(sys.stdin.buffer.read()).decode("ascii"))
```

### C RSA

首先判断给出的RSA公钥、密钥是否正确，然后加密，算法上没什么难度。一开始用Python遇到输入问题，改用C++没有问题了。Python输入处理可以这样：

```python
try:
    e, d, p, q, n = map(int, input().split())
except EOFError:
    break
```

***

## 4-7 二分法

### A Project

本周实现Dijkstra模板。

注意边权不一定满足交换律(例如string)，所以Dijkstra中必须用dist[u] + weight，不可改变顺序，这个bug卡了很久。

### B 暗杀之狼

$256\times 256$地图上设定好敌人的位置，给定一个坐标和射击距离，判断最多能射杀多少敌人。对每个区域，最远的点能被覆盖，则一定都可以，最近的点不能被覆盖，则一定都不可以。如果是两者之间的状态，将该区域分成4块递归处理

### C OmegaGo

围棋判断最多提多少子，模拟+dfs即可

***

## 4-8 动态规划

### A Project

实现Bellman-Ford模板，通过类型萃取从传入的图中得到权重类型。

### B 头脑最短路

Dijkstra+数学期望，只需要把Dijkstra的条件判断修改一下就行了

### C 计算问题

本质上就是用数位dp计算[1, x-1]和[1, y]中分别有多少个整数满足各个数位之和整除整数本身。提交T了很多次，花费了很多时间，总结出如下教训：

1. 自顶而下未必比自下而上效率低，有时自顶向下+记忆化搜索可以方便地对递归剪枝
2. 本题中rec数组对每个除数都需要memset一次，但是本题TLE的主要原因在于计算x-1和y可以公用rec数组，这样计算量减小了接近一半
3. memset为-1可以提高效率，因为有时rec=0是返回值

***

## 4-9 多源最短路

### A Project

模板实现多源最短路即可，没有遇到什么问题

### B yls的假期

动态规划+快速幂思想，如果直接用递推会TLE，这时加上**快速幂**的思想即可，这题的思路比较简单清晰，但是很有启发意义。

### C 瑞士轮

本题就是模拟题，其实没什么难度，但是一开始题面有误(体面内容本来也就很多，比较容易读错)。卡了很久，遇到的坑如下：

1. 题面错误
2. 对于long long类型，scanf和printf都需要用%lld，否则可能会出错

### D 玩具车

枚举即可，没什么难度

***

## 4-10 字符串

### A Project

添加异常处理，判定负环

### B 回文串

简单题，不用复杂算法

### C 串匹配

套用KMP算法

### D 机器人

模拟题，难度不大

***

## 4-11 

### A Project

实现二部图匹配及其异常检测

### B 循环节

需要理解KMP算法的next数组原理，并应用于本题

### C 高效键盘

需要运用dp。很容易TLE，我一开始一个一个输出答案字符，结果有一个点过不了。改成存在char数组一并输出就解决了。最后算法常数比较大，因为我用rec数组记录路径，这其实没有必要。

### D 宿舍分配

用字典树+贪心算法即可。我一开始总是TLE，把struct中next[26]改成STL或者用数组存放结构体而非new delete即可通过。

